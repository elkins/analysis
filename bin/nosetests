#!/usr/bin/env bash

# Function to display usage information
usage() {
    echo "Usage: $0 [-o <output folder>] [-g <group id>] <test_files>"
    exit 1
}

# Parse command-line options
while getopts ":o:g:" OPT; do
    case $OPT in
        o)
            outputDir=$OPTARG
            outputDir="${outputDir%/}/"
            ;;
        g)
            groupId=$OPTARG
            ;;
        \? | :)
            echo "Invalid option or missing argument: -$OPTARG" >&2
            usage
            ;;
    esac
done

# Shift the arguments to get the test-files
shift $((OPTIND - 1))

# Check if test-files are provided
[[ $# -eq 0 ]] && usage

# Get the script-file if symbolic
_path="${BASH_SOURCE[0]}"

# Iterate through the symbolic links if needed
for _ in {1..3}; do
    if [[ -d ${_path} ]]; then
        # Change to absolute path
        _path="$(
            cd "${_path}" || exit
            pwd -P
        )"
    fi
    _pathlink="$(readlink "${_path}")"
    _pathlink="${_pathlink:-${_path}}"
    _path="$(dirname "${_pathlink}")"
done

CCPNMR_TOP_DIR="${_pathlink}"
export CCPNMR_TOP_DIR
source "${CCPNMR_TOP_DIR}"/bin/paths.sh

NOSETESTS="${CONDA}"/bin/nosetests

FILENAME=$*
FILENAME=${FILENAME##*/}
FILENAME=${FILENAME%.*}
STAMP="$(date +%Y%m%d_%H%M%S)"

# Create the output directory if it doesn't exist
if [[ -n $outputDir && ! -d $outputDir ]]; then
    mkdir -p "$outputDir" || exit
fi

# Execute nose-tests and redirect all output to file in the specified output folder
"${NOSETESTS}" -vs "$@" > "${outputDir}TESTOUT_$(basename "$FILENAME")${groupId:+_$groupId}_${STAMP}.txt" 2>&1

## write out any lines that contain the fail code
#while read -r p; do
#    if [[ ${p} == *"FAIL:"* ]]; then
#        echo "$p"
#    fi
#done < "TESTOUT_${STAMP}.txt" - this loop not really necessary as errors should be collated at the bottom
